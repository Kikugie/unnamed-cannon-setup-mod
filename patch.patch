diff --git a/src/main/java/jk/tree/KDTree.java b/src/main/java/jk/tree/KDTree.java
new file mode 100644
index 0000000..d24087b
--- /dev/null
+++ b/src/main/java/jk/tree/KDTree.java
@@ -0,0 +1,419 @@
+package jk.tree;
+/*
+ ** KDTree.java by Julian Kent
+ **
+ ** Licenced under the  Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
+ **
+ ** Licence summary:
+ ** Under this licence you are free to:
+ **      Share : copy and redistribute the material in any medium or format
+ **      Adapt : remix, transform, and build upon the material
+ **      The licensor cannot revoke these freedoms as long as you follow the license terms.
+ **
+ ** Under the following terms:
+ **      Attribution:
+ **            You must give appropriate credit, provide a link to the license, and indicate
+ **            if changes were made. You may do so in any reasonable manner, but not in any
+ **            way that suggests the licensor endorses you or your use.
+ **      NonCommercial:
+ **            You may not use the material for commercial purposes.
+ **      ShareAlike:
+ **            If you remix, transform, or build upon the material, you must distribute your
+ **            contributions under the same license as the original.
+ **      No additional restrictions:
+ **            You may not apply legal terms or technological measures that legally restrict
+ **            others from doing anything the license permits.
+ **
+ ** See full licencing details here: http://creativecommons.org/licenses/by-nc-sa/3.0/
+ **
+ ** For additional licencing rights (including commercial) please contact jkflying@gmail.com
+ **
+ */
+
+import net.minecraft.util.math.Vec3d;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+public class KDTree<T> {
+    private static final int _bucketSize = 10;
+
+    private final int _dimensions = 3;
+    private int _nodes;
+    private final Node root;
+    private final ArrayList<Node> nodeList = new ArrayList<>();
+    private double[] mem_recycle;
+    private final double[] bounds_template;
+    private final ContiguousDoubleArrayList nodeMinMaxBounds;
+
+    public KDTree() {
+        nodeMinMaxBounds = new ContiguousDoubleArrayList(1024 / 8 + 2 * _dimensions);
+        mem_recycle = new double[_bucketSize * _dimensions];
+
+        bounds_template = new double[2 * _dimensions];
+        Arrays.fill(bounds_template, Double.NEGATIVE_INFINITY);
+        for (int i = 0, max = 2 * _dimensions; i < max; i += 2) {
+            bounds_template[i] = Double.POSITIVE_INFINITY;
+        }
+
+        root = new Node();
+    }
+
+    public int size() {
+        return root.entries;
+    }
+
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    public void addPoint(double[] location, T payload) {
+        Node addNode = root;
+        // Do a Depth First Search to find the Node where 'location' should be
+        // stored
+        while (addNode.pointLocations == null) {
+            addNode.expandBounds(location);
+            if (location[addNode.splitDim] < addNode.splitVal) {
+                addNode = nodeList.get(addNode.lessIndex);
+            } else {
+                addNode = nodeList.get(addNode.moreIndex);
+            }
+        }
+        addNode.expandBounds(location);
+
+        int nodeSize = addNode.add(location, payload);
+
+        if (nodeSize % _bucketSize == 0) {
+            addNode.split();
+        }
+    }
+
+    public SearchResult<T> nearestNeighbour(Vec3d searchLocation) {
+        IntStack stack = new IntStack();
+        PriorityQueue<T> results = new PriorityQueue<>(1, true);
+
+        stack.push(root.index);
+
+        boolean added = false;
+
+        while (stack.size() > 0) {
+            int nodeIndex = stack.pop();
+            if (!added || results.peekPriority() > pointRectDist(nodeIndex, searchLocation)) {
+                Node node = nodeList.get(nodeIndex);
+                if (node.pointLocations == null) {
+                    node.search(searchLocation, stack);
+                } else {
+                    added |= node.search(searchLocation, results) > 0;
+                }
+            }
+        }
+
+        double[] priorities = results.priorities;
+        ArrayList<T> elements = results.elements;
+
+        if (priorities.length == 0) {
+            return null;
+        }
+
+        return new SearchResult<>(priorities[0], elements.get(0));
+    }
+
+    double pointRectDist(int offset, final Vec3d location) {
+        offset *= 2 * _dimensions;
+        double distance = 0;
+        final double[] array = nodeMinMaxBounds.array;
+
+        double bv = array[offset];
+        double lv = location.x;
+        if (bv <= lv) {
+            bv = array[offset + 1];
+        }
+        distance += sqr(bv - lv);
+
+        bv = array[offset + 2];
+        lv = location.y;
+        if (bv <= lv) {
+            bv = array[offset + 3];
+        }
+        distance += sqr(bv - lv);
+
+        bv = array[offset + 4];
+        lv = location.z;
+        if (bv <= lv) {
+            bv = array[offset + 5];
+        }
+        distance += sqr(bv - lv);
+
+        return distance;
+    }
+
+    double pointDist(double[] arr, Vec3d location, int index) {
+        int offset = (index + 1) * _dimensions;
+
+        return sqr(arr[offset - 1] - location.z)
+                + sqr(arr[offset - 2] - location.y)
+                + sqr(arr[offset - 3] - location.x);
+    }
+
+    public static class SearchResult<S> {
+        public double distance;
+        public S payload;
+
+        SearchResult(double dist, S load) {
+            distance = dist;
+            payload = load;
+        }
+    }
+
+    private class Node {
+
+        // for accessing bounding box data
+        // - if trees weren't so unbalanced might be better to use an implicit
+        // heap?
+        int index;
+
+        // keep track of size of subtree
+        int entries;
+
+        // leaf
+        ContiguousDoubleArrayList pointLocations;
+        ArrayList<T> pointPayloads = new ArrayList<>(_bucketSize);
+
+        // stem
+        // Node less, more;
+        int lessIndex, moreIndex;
+        int splitDim;
+        double splitVal;
+
+        Node() {
+            this(new double[_bucketSize * _dimensions]);
+        }
+
+        Node(double[] pointMemory) {
+            pointLocations = new ContiguousDoubleArrayList(pointMemory);
+            index = _nodes++;
+            nodeList.add(this);
+            nodeMinMaxBounds.add(bounds_template);
+        }
+
+        void search(Vec3d searchLocation, KDTree.IntStack stack) {
+            if (axis(searchLocation, splitDim) < splitVal) {
+                stack.push(moreIndex).push(lessIndex); // less will be popped
+                // first
+            } else {
+                stack.push(lessIndex).push(moreIndex); // more will be popped
+                // first
+            }
+        }
+
+        // returns number of points added to results
+        int search(Vec3d searchLocation, PriorityQueue<T> results) {
+            int updated = 0;
+            for (int j = entries; j-- > 0; ) {
+                double distance = pointDist(pointLocations.array, searchLocation, j);
+                if (results.peekPriority() > distance) {
+                    ++updated;
+                    results.addNoGrow(pointPayloads.get(j), distance);
+                }
+            }
+            return updated;
+        }
+
+        void expandBounds(double[] location) {
+            ++entries;
+            int mio = index * 2 * _dimensions;
+            for (int i = 0; i < _dimensions; ++i, mio += 2) {
+                nodeMinMaxBounds.array[mio] = Math.min(nodeMinMaxBounds.array[mio], location[i]);
+                nodeMinMaxBounds.array[mio + 1] = Math.max(nodeMinMaxBounds.array[mio + 1], location[i]);
+            }
+        }
+
+        int add(double[] location, T load) {
+            pointLocations.add(location);
+            pointPayloads.add(load);
+            return entries;
+        }
+
+        void split() {
+            int offset = index * 2 * _dimensions;
+
+            double diff = 0;
+            for (int i = 0; i < _dimensions; ++i) {
+                double min = nodeMinMaxBounds.array[offset];
+                double max = nodeMinMaxBounds.array[offset + 1];
+                if (max - min > diff) {
+                    double mean = 0;
+                    for (int j = 0; j < entries; ++j) {
+                        mean += pointLocations.array[i + _dimensions * j];
+                    }
+
+                    mean = mean / entries;
+                    double varianceSum = 0;
+
+                    for (int j = 0; j < entries; ++j) {
+                        varianceSum += sqr(mean - pointLocations.array[i + _dimensions * j]);
+                    }
+
+                    if (varianceSum > diff * entries) {
+                        diff = varianceSum / entries;
+                        splitVal = mean;
+
+                        splitDim = i;
+                    }
+                }
+                offset += 2;
+            }
+
+            if (splitVal == Double.POSITIVE_INFINITY) {
+                splitVal = Double.MAX_VALUE;
+            } else if (splitVal == Double.NEGATIVE_INFINITY) {
+                splitVal = Double.MIN_VALUE;
+            } else if (splitVal == nodeMinMaxBounds.array[index * 2 * _dimensions + 2 * splitDim + 1]) {
+                splitVal = nodeMinMaxBounds.array[index * 2 * _dimensions + 2 * splitDim];
+            }
+
+            Node less = new Node(mem_recycle);
+            Node more = new Node();
+            lessIndex = less.index;
+            moreIndex = more.index;
+
+            double[] pointLocation = new double[_dimensions];
+            for (int i = 0; i < entries; ++i) {
+                System.arraycopy(pointLocations.array, i * _dimensions, pointLocation, 0, _dimensions);
+                T load = pointPayloads.get(i);
+
+                if (pointLocation[splitDim] < splitVal) {
+                    less.expandBounds(pointLocation);
+                    less.add(pointLocation, load);
+                } else {
+                    more.expandBounds(pointLocation);
+                    more.add(pointLocation, load);
+                }
+            }
+
+            if (less.entries * more.entries == 0) {
+                nodeList.remove(moreIndex);
+                nodeList.remove(lessIndex);
+            } else {
+                mem_recycle = pointLocations.array;
+                pointLocations = null;
+                pointPayloads.clear();
+                pointPayloads = null;
+            }
+        }
+    }
+
+    private static class PriorityQueue<S> {
+
+        ArrayList<S> elements;
+        double[] priorities;
+        private double minPriority;
+        private int size;
+
+        PriorityQueue(int size, boolean prefill) {
+            elements = new ArrayList<>(size);
+            priorities = new double[size];
+            Arrays.fill(priorities, Double.POSITIVE_INFINITY);
+            if (prefill) {
+                minPriority = Double.POSITIVE_INFINITY;
+                this.size = size;
+            }
+        }
+
+        void addNoGrow(S value, double priority) {
+            int index = searchFor(priority);
+
+            System.arraycopy(priorities, index, priorities, index + 1, size - index - 1);
+            priorities[index] = priority;
+
+            if (elements.size() == priorities.length) {
+                elements.remove(elements.size() - 1);
+            }
+            elements.add(index, value);
+
+            minPriority = priorities[size - 1];
+        }
+
+        int searchFor(double priority) {
+            int i = size - 1;
+            int j = 0;
+            while (i >= j) {
+                int index = (i + j) >>> 1;
+                if (priorities[index] < priority) {
+                    j = index + 1;
+                } else {
+                    i = index - 1;
+                }
+            }
+            return j;
+        }
+
+        double peekPriority() {
+            return minPriority;
+        }
+    }
+
+    private static class ContiguousDoubleArrayList {
+        double[] array;
+        int size;
+
+        ContiguousDoubleArrayList(int size) {
+            this(new double[size]);
+        }
+
+        ContiguousDoubleArrayList(double[] data) {
+            array = data;
+        }
+
+        void add(double[] da) {
+            if (size + da.length > array.length) {
+                array = Arrays.copyOf(array, (array.length + da.length) * 2);
+            }
+
+            System.arraycopy(da, 0, array, size, da.length);
+            size += da.length;
+        }
+    }
+
+    private static class IntStack {
+        int[] array;
+        int size;
+
+        IntStack() {
+            this(64);
+        }
+
+        IntStack(int size) {
+            this(new int[size]);
+        }
+
+        IntStack(int[] data) {
+            array = data;
+        }
+
+        IntStack push(int i) {
+            if (size >= array.length) {
+                array = Arrays.copyOf(array, (array.length + 1) * 2);
+            }
+
+            array[size++] = i;
+            return this;
+        }
+
+        int pop() {
+            return array[--size];
+        }
+
+        int size() {
+            return size;
+        }
+    }
+
+    static double sqr(double d) {
+        return d * d;
+    }
+
+    static double axis(Vec3d v, int axis) {
+        return axis == 0 ? v.x : axis == 1 ? v.y : v.z;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/kikugie/ucsm/CannonMod.java b/src/main/java/me/kikugie/ucsm/CannonMod.java
index 92d0599..3e560d4 100644
--- a/src/main/java/me/kikugie/ucsm/CannonMod.java
+++ b/src/main/java/me/kikugie/ucsm/CannonMod.java
@@ -1,5 +1,6 @@
 package me.kikugie.ucsm;
 
+import jk.tree.KDTree;
 import net.fabricmc.api.ModInitializer;
 import net.fabricmc.fabric.api.client.command.v2.ClientCommandRegistrationCallback;
 import net.fabricmc.fabric.api.client.networking.v1.ClientPlayConnectionEvents;
@@ -10,26 +11,76 @@ import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.file.Files;
+import java.util.*;
 import java.util.logging.Logger;
 
 public class CannonMod implements ModInitializer {
     public static final Logger LOGGER = Logger.getLogger("ucsm");
-    public static Vec3d[] points;
-    public static String[] configs;
+    public static KDTree<String> kdTree;
+    public static final File configDir = new File(MinecraftClient.getInstance().runDirectory, "config/ucsm/");
 
     public static boolean initConfig() {
-        var configDir = new File(MinecraftClient.getInstance().runDirectory, "config/ucsm/");
         if (!configDir.exists()) {
             configDir.mkdirs();
         }
+
         try {
-            points = Arrays.stream(readList(new File(configDir, "Pt.txt"))).map(val -> {
-                var k = val.split(",");
-                return new Vec3d(Float.parseFloat(k[0]), Float.parseFloat(k[1]), Float.parseFloat(k[2]));
-            }).toArray(Vec3d[]::new);
-            configs = readList(new File(configDir, "Ct.txt"));
+            kdTree = new KDTree<>();
+            var packed = new File(configDir, "packed.bin");
+
+            if (packed.exists() && packed.canRead()) {
+                var bytes = Files.readAllBytes(new File(configDir, "packed.bin").toPath());
+                var idx = 0;
+
+                // Binary format:
+                // [propellant{1}number_of_ps{4}[x{8}y{8}z{8}first{1}second{1}third{1}]+]*
+                while (idx < bytes.length) {
+                    // propellant{1}
+                    var tnt = bytes[idx++];
+
+                    // number_of_ps{4}
+                    byte[] lenBytes = new byte[4];
+                    System.arraycopy(bytes, idx, lenBytes, 0, 4);
+                    int len = ByteBuffer.wrap(lenBytes).order(ByteOrder.BIG_ENDIAN).getInt();
+                    idx += 4;
+
+                    // [x{8}y{8}z{8}first{1}second{1}third{1}]+
+                    for (int i = idx, lim = idx + len; i < lim; i += 27) {
+                        byte[] chunk = new byte[27];
+                        System.arraycopy(bytes, i, chunk, 0, 27);
+
+                        byte[] xBytes = new byte[8];
+                        System.arraycopy(chunk, 3, xBytes, 0, 8);
+                        double x = ByteBuffer.wrap(xBytes).order(ByteOrder.BIG_ENDIAN).getDouble();
+
+                        byte[] yBytes = new byte[8];
+                        System.arraycopy(chunk, 11, yBytes, 0, 8);
+                        double y = ByteBuffer.wrap(yBytes).order(ByteOrder.BIG_ENDIAN).getDouble();
+
+                        byte[] zBytes = new byte[8];
+                        System.arraycopy(chunk, 19, zBytes, 0, 8);
+                        double z = ByteBuffer.wrap(zBytes).order(ByteOrder.BIG_ENDIAN).getDouble();
+
+                        kdTree.addPoint(new double[] { x, y, z }, chunk[0] + "," + chunk[1] + "," + chunk[2] + "," + tnt);
+                    }
+
+                    idx += len;
+                }
+            } else {
+                var points = Arrays.stream(readList(new File(configDir, "Pt.txt"))).map(val -> {
+                    var k = val.split(",");
+                    return new double[] { Float.parseFloat(k[0]), Float.parseFloat(k[1]), Float.parseFloat(k[2]) };
+                }).toArray(double[][]::new);
+                var configs = readList(new File(configDir, "Ct.txt"));
+
+                for (int i = 0, lim = points.length; i < lim; i++) {
+                    kdTree.addPoint(points[i], configs[i]);
+                }
+            }
+
             return true;
         } catch (IOException e) {
             LOGGER.warning("Error reading config files");
diff --git a/src/main/java/me/kikugie/ucsm/Command.java b/src/main/java/me/kikugie/ucsm/Command.java
index fe71ee2..896b128 100644
--- a/src/main/java/me/kikugie/ucsm/Command.java
+++ b/src/main/java/me/kikugie/ucsm/Command.java
@@ -15,8 +15,15 @@ import net.minecraft.util.math.Vec3d;
 import net.minecraft.util.math.Vec3i;
 import net.minecraft.world.RaycastContext;
 
-import static me.kikugie.ucsm.CannonMod.configs;
-import static me.kikugie.ucsm.CannonMod.points;
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import static me.kikugie.ucsm.CannonMod.*;
 import static net.fabricmc.fabric.api.client.command.v2.ClientCommandManager.argument;
 import static net.fabricmc.fabric.api.client.command.v2.ClientCommandManager.literal;
 
@@ -41,7 +48,9 @@ public class Command {
                 .then(literal("target")
                         .executes(Command::raycastTarget)
                         .then(argument("pos", BlockPosArgumentType.blockPos())
-                                .executes(Command::posTarget))));
+                                .executes(Command::posTarget)))
+                .then(literal("pack")
+                        .executes(Command::pack)));
     }
 
 
@@ -51,7 +60,8 @@ public class Command {
                   - /ucsm reload: reload config files.
                   - /ucsm precision <int>: maximum distance to the explosion.
                   - /ucsm origin [<pos> <direction>]: set cannon origin to a location, uses player position and facing direction if no arguments provided.
-                  - /ucsm target [<pos>]: output closest configuration to specified position. Uses block player is looking at (even very far) if no argument is provided."""
+                  - /ucsm target [<pos>]: output closest configuration to specified position. Uses block player is looking at (even very far) if no argument is provided.
+                  - /ucsm pack: Packs Ct.txt and Pt.txt into a binary format to reduce file size."""
 
         ));
         return 0;
@@ -103,7 +113,7 @@ public class Command {
     }
 
     private static boolean getTarget(BlockPos pos, FabricClientCommandSource source) {
-        if (points == null || configs == null) {
+        if (kdTree.isEmpty()) {
             source.sendError(Text.of("Config is not loaded!"));
             return false;
         }
@@ -115,30 +125,22 @@ public class Command {
         // God forgive me
         double rotate = switch (direction) {
             case SOUTH -> Math.PI;
-            case EAST -> Math.PI / 2;
-            case WEST -> -Math.PI / 2;
+            case EAST -> Math.PI * 0.5;
+            case WEST -> Math.PI * -0.5;
             default -> 0;
         };
 
         Vec3d target = Vec3d.of(pos)
                 .subtract(origin.getX() - 0.5, origin.getY() - 0.5, origin.getZ() - 0.5)
                 .rotateY((float) rotate);
-        double requiredDistance = sqTntRange;
-        String configuration = null;
-
-        for (int i = 0; i < points.length; i++) {
-            var distance = target.squaredDistanceTo(points[i]);
-            if (distance <= requiredDistance) {
-                requiredDistance = distance;
-                configuration = configs[i];
-            }
-        }
 
-        if (configuration == null) {
+        var result = kdTree.nearestNeighbour(target);
+        if (result == null) {
             source.sendError(Text.of("Your target is too far away!"));
             return false;
         }
-        source.sendFeedback(Text.of(String.format("§aConfiguration: %s; distance: %.2f", configuration, Math.sqrt(requiredDistance))));
+
+        source.sendFeedback(Text.of(String.format("§aConfiguration: %s; distance: %.2f", result.payload, Math.sqrt(result.distance))));
         return true;
     }
 
@@ -166,4 +168,65 @@ public class Command {
                 accessor.getZ().toAbsoluteCoordinate(pos.z)
         );
     }
+
+    private static int pack(CommandContext<FabricClientCommandSource> context) {
+        var cFile = new File(configDir, "Ct.txt");
+        var pFile = new File(configDir, "Pt.txt");
+        var packedFile = new File(configDir, "packed.bin");
+
+        try (BufferedReader c = new BufferedReader(new FileReader(cFile));
+             BufferedReader p = new BufferedReader(new FileReader(pFile));
+             FileOutputStream fos = new FileOutputStream(packedFile.getAbsolutePath())) {
+
+            Map<Byte, List<Byte>> map = new HashMap<>();
+            String line;
+
+            while ((line = c.readLine()) != null) {
+                String[] split = line.split(",");
+                byte tnt = Byte.parseByte(split[3]);
+
+                String[] pSplit = p.readLine().split(",");
+                ByteBuffer buffer = ByteBuffer.allocate(24);
+                for (int i = 0; i < 3; ++i) {
+                    buffer.putDouble(i * 8, Double.parseDouble(pSplit[i]));
+                }
+
+                List<Byte> list = Arrays.stream(split).limit(3).map(Byte::parseByte).collect(Collectors.toList());
+                for (byte b : buffer.array()) {
+                    list.add(b);
+                }
+
+                if (map.containsKey(tnt)) {
+                    map.get(tnt).addAll(list);
+                    continue;
+                }
+                map.put(tnt, list);
+            }
+
+            for (Map.Entry<Byte, List<Byte>> entry : map.entrySet()) {
+                Byte k = entry.getKey();
+                List<Byte> v = entry.getValue();
+                byte[] a = new byte[5 + v.size()];
+                a[0] = k;
+                ByteBuffer b = ByteBuffer.allocate(4);
+                b.putInt(v.size());
+                for (int i = 0; i < 4; ++i) {
+                    a[i + 1] = b.get(i);
+                }
+
+                for (int i = 0; i < v.size(); ++i) {
+                    a[i + 5] = v.get(i);
+                }
+                fos.write(a);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            return 1;
+        }
+
+        var originalSize = cFile.length() + pFile.length();
+        context.getSource().sendFeedback(Text.of(String.format("§oPacked successfully! Packed size: %d bytes (%.2f%% of original size)", packedFile.length(), packedFile.length() * 100D / originalSize)));
+
+        return 1;
+    }
 }
